## 4.4  运算符重载函数作为类成员函数和友元函数

对运算符重载的函数有两种处理方式：

1、作为类的成员函数

```cpp
Complex Complex::operator+(Complex& c2);
```

*+是双目运算符，其中一个参数是隐含的，是用this指针隐式地访问类对象的成员*

```cpp
c1.operator+(c2);
```

通过对象c1调用运算符重载函数operato+，并以表达式中第二个参数c2作为函数实参。



2、不是类的成员函数，在类中把它声明为友元函数（友元运算符重载函数）

```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
    Complex()
    {
        real=0;imag=0;
    }
    Complex(double r,double i)
    {
        real=r;imag=i;
    }
    friend Complex operator+(Complex& c1,Complex& c2);//重载函数作为友元函数
    void display();
private:
    double real;
    double imag;
};
Complex operator+(Complex& c1,Complex& c2)//定义运算符“+”重载函数
{
    return Complex(c1.real+c2.real,c1.imag+c2.imag);
}
void Complex::display()
{
    cout<<"("<<real<<","<<imag<<")"<<endl;
}
int main()
{
    Complex c1(3,4),c2(5,-10),c3;
    c3=c1+c2;
    cout<<"c1= ";c1.display();
    cout<<"c2= ";c2.display();
    cout<<"c1+c2= ";c3.display();
}


```

*运算符+重载为非成员函数后，编译系统将c1+c2解释为：*

```cpp
operator+(c1,c2);
```

**成员函数vs友元函数**

**成员函数** ：可以通过this指针自由地方位本类数据成员，少写一个函数参数。但必须要求运算表达式中的第一个参数为类对象，且与运算符函数的类型相同。

```cpp
c3=c1+c2;//c1是Complex类对象，且operator+函数是Complex类型，合法。
```

若想实现一个复数和一个整数相加，注意左侧应为Complex类对象：

```cpp
Complex Complex::operator+(int& i)
{return Complex(real+i,imag);}
```

```cpp
c3=c2+i;//正确
```

```cpp
c3=i+c2;//编译出错，无法调用i.operator+函数
```

**友元函数** ：

类中声明：

```cpp
friend Complex operator+(int& i,Complex& c);//第一个参数可以不是类对象
```

类外定义：

```cpp
Complex operator+(int& i,Complex& c)//非成员函数
{return Complex(i+c.real,c.imag);}
```

将双目运算符重载为友元函数：由于友元函数不是成员函数，在函数形参表列中必须有两个参数，不能省略。

*形参顺序任意，不要求第一个为类对象。但在运算符表达式中，运算符左侧操作数应与参数类型顺序相对应*：

```cpp
c3=i+c2;//正确
```

```cpp
c3=c2+i;//错误，类型不匹配
```

*若想交换律在这里适用，则需要再重载一次运算符+*

```cpp
Complex operator+(Complex& c,int& i)
{return Complex(c.real+i,c.imag);}//这样c3=c2+i也合法
```

到底选择成员函数还是友元函数？给出以下参考：

**C++规定，赋值运算符=，下标运算符[]，函数调用运算符()，成员运算符->必须作为成员函数。

**流插入<<和流提取运算符>>、类型转换运算符只能作为友元函数。

**一般将单目运算符和复合运算符（+=，-=，/=，<<=）重载为成员函数

**一般将双目运算符重载为友元函数
