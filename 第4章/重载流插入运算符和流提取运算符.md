## 4.7 重载流插入运算符和流提取运算符

如果想用<</>>输出/输入用户自己定义的类型的数据，必须对他们进行重载

其函数形式如下：

```cpp
istream&operator>>(istream&,自定义类&);
ostream&operator<<(ostream&,自定义类&)；
```

*第一个参数和函数类型必须是istream/ostream而不是用户自己定义的类---->只能定义为**友元函数** 



### 4.7.1 重载流插入运算符<<

#### 用重载运算符<<实现复数的输出

```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
    Complex(){real=0;imag=0;}
    Complex(double r,double i){real=r;imag=i;}
    Complex operator+(Complex& c2);
    friend ostream&operator<<(ostream&,Complex&);//运算符<<重载为友元函数
private:
    double real;
    double imag;
};
Complex Complex::operator+(Complex& c2)
{
    return Complex(real+c2.real,imag+c2.imag);
}
ostream&operator<<(ostream& output,Complex& c)//形参output、c是实参的引用
{
    output<<"("<<c.real<<"+"<<c.imag<<"i)"<<endl;
    return output;
}
int main()
{
    Complex c1(2,4),c2(6,10),c3;
    c3=c1+c2;
    cout<<c3;//重载运算符<<，输出Complex类对象
    return 0;
}


```

**注意：** 

```cpp
cout<<c3;
operator<<(cout,c3);//二者含义一致
```

*调用函数时，形参output成为实参cout的引用，形参c成为c3的引用。*

```cpp
//函数调用时相当于在执行：
cout<<"("<<c3.real<<"+"<<c3.imag<<"i)"<<endl;
return cout;
```

**return output作用：能连续向输出流插入信息*

```cpp
cout<<c3<<c2;
```

先处理cout<<c3,即

```cpp
(cout<<c3)<<c2;
```

执行（cout<<c3）的结果就是具有新内容的流对象cout，因此相当于cout(新值)<<c2。

运算符<<左侧是ostream类对象cout,右侧是Complex类对象c2，再次调用<<重载函数，接着向输出流插入c2的数据。



**注意区分<<类型*

```cpp
cout<<c3<<5<<endl;
```

第一个<<是调用重载的流插入符（右侧为Complex类对象）

后两个<<是预定义的流插入符



**在Complex类中定义了友元重载<<函数,因此只有在输出Complex类对象才能使用重载运算符*

```cpp
cout<<time1;//非法，time1不是Complex类对象
```



### 4.7.2 重载流提取运算符>>

```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
    friend ostream&operator<<(ostream&,Complex&);
    friend istream&operator>>(istream&,Complex&);
private:
    double real;
    double imag;
};
ostream&operator<<(ostream&output,Complex& c)
{
    output<<"("<<c.real<<"+"<<c.imag<<"i)"<<endl;
    return output;
}
istream&operator>>(istream& input,Complex& c)
{
    cout<<"input real part and imaginary part of complex number: ";
    input>>c.real>>c.imag;
    return input;
}
int main()
{
    Complex c1,c2;
    cin>>c1>>c2;
    cout<<"c1= "<<c1<<endl;
    cout<<"c2= "<<c2<<endl;
    return 0;
}

```

<img src="file:///C:/Users/a3341/Pictures/Typedown/b3c22278-47bb-467e-8afe-8ff78bb92699.png" title="" alt="b3c22278-47bb-467e-8afe-8ff78bb92699" style="zoom:50%;">

//此时运行结果是正确的，但假如数据是负数呢？

*输入3 6，4 -10*

<img src="file:///C:/Users/a3341/Pictures/Typedown/26553c02-5785-4253-9509-839b6719ec4e.png" title="" alt="26553c02-5785-4253-9509-839b6719ec4e" style="zoom:50%;">

显然多出的加号是我们不希望看到的，完善程序：

```cpp
ostream&operator<<(ostream&output,Complex& c)
{
    output<<"("<<c.real;
    if(c.imag>=0) output<<"+";//如果虚部大于等于0，输出+
    output<<c.imag<<")"<<endl;
    return output;
}
```

<img src="file:///C:/Users/a3341/Pictures/Typedown/50158063-51e5-4e78-98e1-06385198b58a.png" title="" alt="50158063-51e5-4e78-98e1-06385198b58a" style="zoom:50%;">


