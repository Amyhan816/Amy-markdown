## 4.9 不同类型数据间的转换

### 4.9.1 标准类型数据间的转换

*隐式类型转换*

```cpp
int i=6;
i=7.5+i;//先将i转换为double型，两数相加得到13.5.向整型变量赋值时再转换为13 
```

//这种转换由C++编译系统自动完成，用户无须干预



*显示类型转换*

其形式：**类型名（数据）**

```cpp
int(89.5);//将89.5转换为89
```



标准类型间的转换并不难，但现在用户自定义了类，能否将自定义类转换为标准类型？能否将一个类的对象转换为另一个类的对象？

关键是让编译系统知道怎样进行这些转换，需要定义专门的函数来处理。



### 4.9.2 把其他类型数据转换为类对象——用转换构造函数

**转换构造函数：将一个其他类型的数据转换成一个类的对象**

回顾：

默认构造函数 

Complex（）;//没有参数

用于初始化的构造函数 

Complex(double r,double i);//形参表列中一般有两个以上参数

用于复制对象的复制构造函数

 Complex(Complex &c)//形参是本类对象的引用

*转换构造函数：只有一个形参*

```cpp
Complex(double r){real=r;imag=0;}//将double型参数r转换成Complex类对象，将r作为复数的实部，虚部为0
```



以上构造函数可以同时出现在一个类中，他们都是构造函数的**重载** 

```cpp
Complex c1(3.5);//建立对象c1，由于只有一个参数，调用转换构造函数
```

```cpp
Complex(3.6);//建立了一个无名对象，合法，但无法使用它
```

```cpp
Complex c1;
c1=Complex(3.6);//将无名对象的值（3.6+0i）赋给c1
```

```cpp
//假设已经对运算符+进行了重载,可以对两个Complex类对象相加
c=c1+2.5;//编译出错，其中一个是double型
```

*此时可以先将2.5转换为Complex类无名对象，再进行相加：*

```cpp
c=c1+Complex(2.5);//合法
```

**总结：使用转换构造函数方法如下**

1、先声明一个类（如Complex）

2、在这个类中定义一个只有一个参数的构造函数，参数的类型是需要转换的类型，在函数体中指定转换的方法

3、在该类的作用域内用**类名（指定类型的数据）** 进行转换

*如：Complex（double r）*：将双精度数据r转换成Complex型数据



### 4.9.3 将类对象转换为其他类型数据——用类型转换函数

**类型转换函数：将一个类的对象转换为另一个类型的数据**

```cpp
operator double()
{return real;}
```

//作用：将一个Complex对象转换为一个double型数据，其值是Complex类中的数据成员real的值。

其中**operator double** 是函数名

类型转换函数的一般形式：

```cpp
operator 类型名()
{实现转换的语句}
```

*函数名前不能指定函数类型，函数没有参数（其返回值类型由指定的类型名决定）

*类型转换函数只能作为**成员函数** （因为转换的主体是本类的对象）



*若已定义d1,d2为double型变量，c1,c2为Complex类对象.* 

如类中已经定义了类型转换函数，则：

```cpp
d1=d2+c1;
//编译系统发现+左侧是double型，右侧是Complex类。如果没有对+进行重载，则会检查有没有类型转换函数（Complex->double）.发现有该函数，便调用该函数把c1转换为double型数据，建立一个临时的double数据并与d2相加，最后将一个double值赋给d1
```

如果类中已经定义了转换构造函数并且重载了+

```cpp
c2=c1+d2;
//编译系统发现已经有了operator+函数，但它是两个Complex类的友元函数。但是d2是double型且没有类型转换函数，于是编译系统就去找有没有转换构造函数，发现有，就调用构造转换函数Complex（d2），建立一个临时Complex类对象，再调用operator+进行两个复数的相加，将一个Complex类对象赋给c2.
```

```cpp
c2=c1+Complex(d2);//相当于执行此表达式
```

#### 将一个double数据和一个Complex类数据相加

```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
    Complex(){real=0;imag=0;}
    Complex(double r,double i){real=r;imag=i;}
    operator double(){return real;}//定义类型转换函数
private:
    double real;
    double imag;
};
int main()
{
    Complex c1(3,4),c2(5,-10),c3;
    double d;
    d=2.5+c1;//自动调用operator double函数
    cout<<d<<endl;
    return 0;
}


```

*重载函数都使用operator关键字，它的意思是“运算符”*

类型转换函数=类型转换运算符函数=类型转换运算符重载函数

其优点：如果要对一个Complex类对象和一个double型数据进行+-*/等算术运算，需要对每个运算符都进行重载，非常麻烦！

**但如果用类型转换函数对double进行重载（Complex——>double）,就不用对各种运算符进行重载。Complex类对象可以被自动转换为double型数据。**



```cpp
#include<iostream>
using namespace std;
class Complex
{
public:
    Complex(){real=0;imag=0;}
    Complex(double r,double i){real=r;imag=i;}
    Complex(double r){real=r;imag=0;}//定义转换构造函数
    friend Complex operator+(Complex c1,Complex c2);//声明重载+的函数为友元函数
    void display();
private:
    double real;
    double imag;
};
Complex operator+(Complex c1,Complex c2)
{
    return Complex(c1.real+c2.real,c1.imag+c2.imag);
}
void Complex::display()
{
    cout<<"("<<real;
    if(imag>=0) cout<<"+";
    cout<<imag<<"i)"<<endl;
}
int main()
{
    Complex c1(3,4),c2(5,-10),c3;
    c3=c1+2.5;//已重载+，需要将2.5转换为Complex类对象。调用转换构造函数
    c3.display();
    return 0;
}


```

**注意**

由于“+”函数重载为友元函数，因此交换律在这里是合法的。即

```cpp
c3=c1+2.5;
c3=2.5+c1;//都是合法的
```

但如果“+”的重载函数为成员函数

```cpp
operator+(Complex c2);//第一个参数省略，隐含this所指的对象
```

```cpp
c1+2.5//解释为c1.operator+(2.5)
```

*通过转换构造函数Complex（2.5），建立了一个临时Complex类对象，即*

```cpp
c1.operator+(Complex(2.5))//合法
```

但如果是

```cpp
2.5+c2//相当于（2.5）.operator+c1,显然2.5不是Complex对象，无法调用转换构造函数，错误。
```

**总结：如果运算符函数重载为成员函数，它的第一个参数必须是本类的对象。当第一个操作数不是本类对象时，不能将运算符重载为成员函数。如果将运算符+重载为成员函数，交换律不适用。**



*将上面的程序添加类型转换函数*

```cpp
operator double(){return real;}
```

<img title="" src="file:///C:/Users/a3341/Pictures/Typedown/8d7c48e5-41d1-4eb6-b80b-7f25f6b1d2bd.png" alt="8d7c48e5-41d1-4eb6-b80b-7f25f6b1d2bd" style="zoom:50%;">

#这里c3=c1+2.5报错，因为出现了歧义：

系统不知道是要将2.5转换为Complex类对象，调用+重载对两个Complex类对象进行相加，还是调用类型转换函数将c1转换为double型数据，与2.5相加。

如果要用类型转换函数，则应删除对+的重载函数。
