## 3.8 允许访问私有数据的“朋友”

### 3.8.1 可以访问私有数据的友元函数

#### 1、将普通函数声明为友元函数

```cpp
#include <iostream>
using namespace std;
class Time
{
public:
    Time(int,int,int);
    friend void display(Time&);//声明display函数为Time类的友元函数
private:
    int hour;
    int minute;
    int sec;
};
Time::Time(int h,int m,int s)
{
    hour=h;
    minute=m;
    sec=s;
}
void display(Time& t)//这是普通函数，形参t是Time类对象的引用
{
    cout<<t.hour<<":"<<t.minute<<":"<<t.sec<<endl;
}
int main()
{
    Time t1(10,13,56);
    display(t1);
    return 0;
}


```

*display函数被声明为Time类友元函数，可以引用其私有成员*

**引用私有数据成员时，必须加上对象名**

```cpp
cout<<hour<<endl;//错误。因为display函数没有this指针，不能默认引用Time类的数据成员，必须指定访问的对象！
```

#### 2、用友元成员函数访问私有数据

*friend函数也可以是另一个类中的成员函数*

```cpp
#include<iostream>
using namespace std;
class Date;//对Date类的提前引用声明
class Time
{
public:
    Time(int,int,int);
    void display(Date&);//display是成员函数，形参是Date类对象的引用
private:
    int hour;
    int minute;
    int sec;
};
class Date
{
public:
    Date(int,int,int);
    friend void Time::display(Date&);//声明Time类的display函数为本类的友元成员函数
private:
    int month;
    int day;
    int year;
};
Time::Time(int h,int m,int s)
{
    hour=h;
    minute=m;
    sec=s;
}
void Time::display(Date& d)//形参引用Date类对象
{
    cout<<d.month<<"/"<<d.day<<"/"<<d.year<<endl;//引用Date类对象的私有数据
    cout<<hour<<":"<<minute<<":"<<sec<<endl;//引用本类对象的私有数据
}
Date::Date(int m,int d,int y)
{
    month=m;
    day=d;
    year=y;
}
int main()
{
    Time t1(12,23,34);
    Date d1(12,25,2025);
    t1.display(d1);//调用t1中的display函数，实参是Date类对象d1
    return 0;
}


```

//如果不用友元函数，则要在两个类中分别包含一个输出函数（display1、display2），在主函数调用这两个函数，显然会更麻烦

***输出本类对象：不用加对象名*

```cpp
cout<<hour<<":"<<minute<<":"<<sec<<endl;
```

***输出Date类对象：必须加上对象名*

```cpp
cout<<d.month<<"/"<<d.day<<"/"<<d.year<<endl;
```

**注意**

1、调用display函数时，要加上display所在对象名（t1）

```cpp
t1.display(d1);
```

2、display函数实参为Date类对象d1，否则无法访问d1的私有数据

3、在Time：：display函数中引用Date类私有数据必须加上对象名，如d.month



*一个函数可以被多个类声明为friend，即它可以引用多个类中的私有数据*



### 3.8.2 可以访问私有数据的友元类

*可以将类B声明为类A的朋友，这样类B就是类A的友元类。友元类B中的所有函数都是类A的友元函数，可以访问类A的所有成员*

**在类A的定义体中：**

```cpp
friend B;//声明类B为友元类
```

注意：

**1、友元关系是单向的

**2、友元关系不能传递

**友元是对封装原则的一种破坏，要恰当地使用** ！
