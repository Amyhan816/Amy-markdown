## 3.4 公用数据的保护

### 3.4.1 定义常对象

```cpp
Time const t1(12,23,34);
const Time t1(12,23,34);//二者等价
```

-常对象必须有初值



//常对象只能调用它的常对象函数

```cpp
const Time t1(12,23,34);
t1.get_time();//试图调用常对象的普通成员函数，非法
```

-可以将函数声明为const

```cpp
void get_time() const;//const型函数
```

-常函数可以访问常对象中的数据成员，但不允许修改常对象中数据的值



-特殊地，如果想修改常对象中某个数据成员的值，可以将该数据成员声明为mutable

```cpp
mutable int count;//此时可以用声明为const的成员函数修改count的值
```



### 3.4.2 定义常对象成员

#### *常数据成员*

```cpp
const int hour;//定义hour为常数据成员
```

```cpp
Time::Time(int h)
{hour=h;}//hour已是常数据成员，这里又把h赋值给hour，非法
```

```cpp
Time::Time(int h):hour(h){}//这里使用了参数初始化表，发生在对象构造的正式初始化阶段
```

总结：

构造函数只能通过参数初始化表对常数据成员进行初始化。

#### *常成员函数*

常成员函数只能引用本类的数据成员，而不能修改他们。

```cpp
void get_time() const;
```

//注意：常成员函数不能调用另一个非const成员函数



### 3.4.3 指向对象的常指针

将指针变量声明为const型，其指向保持不变

```cpp
Time t1(12,23,34),t2;
Time * const ptr1=&t1;//ptr1指向t1，其指向保持不变
ptr1=&t2;//错误
```

定义指向对象的常指针变量一般形式：类名 * const 指针变量名；

//指针虽不能改变指向的对象，但可以改变其所指对象的值



#### 3.4.4 指向常对象的指针变量

```cpp
const char *ptr;//定义了一个指向常变量的指针变量
```

*const写在最左侧，表明指针变量ptr指向的char变量是常变量



*如果一个对象已经被声明为常变量，只能用指向常变量的指针变量指向它

```cpp
const char c[]="boy";//定义const型的char数组
const char *p1;//定义p1为指向const型的char变量的指针变量
p1=c;//合法，p1指向常变量c
char *p2=c;//不合法，p2不是指向常变量的指针变量
```

*指向常变量的指针也可以指向未被声明为const的变量。此时不能通过此指针变量改变该变量的值。

```cpp
char c1='a';
const char *p;
p=&c1;
*p='b';//非法，不能通过p改变变量c1的值
c1='b';//合法，没有通过p修改c1，c1不是const型变量
```

*指向常变量的指针变量可以指向const型和非const型的变量

*指向非const型变量的指针变量只能指向非const的变量



//指向常变量----->指向常对象//



1、一个对象已被声明为常对象，只能用指向常对象的指针变量指向它

2、一个指针变量被定义为指向常对象的指针变量，并使它指向一个非const对象，那么它指向的对象不能通过该指针变量改变。

```cpp
Time t1(12,23,34);//定义非const型对象t1
const Time *p=&t1;//定义指向常对象的指针变量p，并使其指向t1
t1.hour=18;//合法，t1不是常对象
(*p).hour=18;//非法，不能通过指针p改变t1
```

*如果希望不改变t1，可把它定义为const型

```cpp
const Time t1(12,23,34);
```

**注意区分**

```cpp
Time * const p;//指向对象的常指针变量
const Time *p;//指向常对象的指针变量
```

3、指向常对象的指针变量常用于函数形参，目的是保护形参指针所指向的对象，使它在函数执行过程中不被修改。

```cpp
int main()
{
    void fun(const Time *);
//Time *后没有参数名：函数声明只需要知道参数类型，参数名p可省略
    Time t1(12,23,34);
    fun(&t1);//实参是对象t1的地址
    return 0;
}

void fun(const Time *p)//函数定义必须有参数名
{
    p->hour=18;//错误，这里形参p为指向常对象的指针变量，保证传进来的实参不被函数修改
    cout<<p->hour<<endl;
}
```

**如果希望调用函数时对象的值不被修改，就应当把形参定义为指向常对象的指针变量，同时用对象的地址作实参（对象可以是const或非const）**

//使用值传递：

```cpp
void fun(Time t);
...
fun(t1);
...
```

可以修改形参t的值，但不能改变其对应实参t1的值。在函数调用时会建立新的对象t，它是实参对象t1的拷贝。实参传值给形参，二者分别占用不同的存储空间，无论形参是否修改都不会影响实参的值。此方法由于要产生实参的拷贝，开销大。



4、对于一个指向常对象的指针变量，不能修改其指向对象的值，但可以修改指针自身的值

```cpp
const Time *p=&t1;
p=&t2;//p改为指向t2，合法
```



### 3.4.5 对象的常引用

```cpp
#include<iostream>
using namespace std;
class Time
{
public:
    Time(int,int,int);
    int hour;
    int minute;
    int sec;
};
Time::Time(int h,int m,int s)//定义构造函数
{
    hour=h;
    minute=m;
    sec=s;
}
void fun(Time &t)//形参t是Time类对象的引用
{
    t.hour=18;
}
int main()
{
    Time t1(10,13,56);
    fun(t1);//实参是Time类对象，可以通过引用修改实参t1的值
    cout<<t1.hour<<endl;//输出t1.hour的值为18
    return 0;
}

```

*如果不希望修改实参t1的值，只需把fun函数声明为const

```cpp
void fun(const Time &t)//常引用
```



### 3.4.6 const型数据小结

| 形式                      | 含义                                 |
|:-----------------------:|:----------------------------------:|
| Time const t1;          | 定义Time类常对象t1，其值保持不变                |
| void Time::fun() const; | fun是Time类的常成员函数，可以引用但不能修改本类中的数据成员  |
| Time * const p;         | p是指向Time类对象的常指针变量，p的指向不能改变         |
| const Time *p;          | p是指向Time类常对象的指针变量，p指向的对象的值不能通过p来改变 |
| const Time &t1=t;       | t1是Time类对象t的引用，二者指向同一存储空间，t的值不能改变  |



## 3.5 对象的动态建立和释放

#### new：动态建立一个对象

```cpp
Box *pt=new Box;定义一个指向Box类对象的指针变量pt，并在pt中存放了新建对象的起始地址
```

在程序中可以通过pt访问新建的对象

```cpp
cout<<pt->height;
cout<<pt->volume();
```

*一般地，用new建立的动态对象通过指针访问而不是对象名。

*主要用于动态的数据结构，如链表。

**new故障**

如果执行new计算时，内存空间不足，无法开辟所需内存空间时，系统会使new返回一个0指针NULL。



### delete：释放空间

```cpp
delete pt;//释放pt所指向的内存空间
```


