## 3.6 对象的赋值和复制

### 3.6.1 对象的赋值

含义：将同一类中对象的全部数据成员的值赋给另一个对象

一般形式：对象名1=对象名2

```cpp
#include<iostream>
using namespace std;
class Box
{
public:
    Box(int=10,int=10,int=10);
    int volume();
private:
    int height;
    int width;
    int length;
};
Box::Box(int h,int w,int len)
{
    height=h;
    width=w;
    length=len;
}
int Box::volume()
{
    return(height*width*length);
}
int main()
{
    Box box1(15,30,25),box2;
    cout<<"The volume of box1 is "<<box1.volume()<<endl;
    box2=box1;//将box1的值赋给box2
    cout<<"The volume of box2 is "<<box2.volume()<<endl;
    return 0;
}


```

*对象的赋值只是对其中数据成员的赋值，而不是对成员函数赋值

*数据成员占存储空间，赋值的过程是将一个对象的数据成员在存储空间的状态复制给另一对象的数据成员的存储空间*

*而不同对象的成员函数是同意函数代码段，不需要也无法对它们赋值*



*类的数据成员中不能包括动态分配的数据，否则在赋值时可能出现严重后果。

## ⚠ 类中包含动态分配数据成员的风险与解决方案

| 问题场景                            | 现象表现                             | 原因分析                            | 解决方案                                                              |
| ------------------------------- | -------------------------------- | ------------------------------- | ----------------------------------------------------------------- |
| 类成员中直接包含动态分配的数据（例如 `int* data`） | 多个对象使用同一块内存，销毁时程序崩溃（double free） | 默认赋值与拷贝为**浅拷贝**，只复制指针地址，不复制数据内容 | ✅ 手动编写拷贝构造函数与赋值运算符，执行**深拷贝**                                      |
| 在对象间赋值或复制时修改一个对象导致另一个对象的数据也被改动  | 数据混乱、逻辑错误                        | 多个对象的指针成员共享同一地址                 | ✅ 为每个对象分配独立内存；使用深拷贝机制                                             |
| 动态分配的内存未在析构函数中释放                | 内存泄漏                             | 动态申请的资源未释放                      | ✅ 在析构函数中正确 `delete[]` 或使用智能指针                                     |
| 程序复杂，手动管理指针麻烦且易漏                | 程序可维护性差                          | 裸指针需要手动管理生命周期                   | ✅ 使用 `std::vector` 或智能指针（如 `std::unique_ptr` / `std::shared_ptr`） |
| 仅需管理一段连续数据时                     | 容易出错                             | 忘记写深拷贝或析构函数                     | ✅ 推荐用 `std::vector` 自动管理内存                                        |

### 3.6.2 对象的复制

*有时需要用到多个完全相同的对象，可以用到对象的复制机制*

一般形式：类名 对象2（对象1）；

```cpp
Box box2(box1);//用已有的box1复制出一个新对象box2
```

*由于括号内给定的实参是对象，因此编译系统自动调用复制构造函数*

此时调用了特殊地构造函数——**复制构造函数**

```cpp
Box::Box(const Box& b)//只有一个本类的对象参数+采用对象的引用形势
{
    height=b.height;
    width=b.width;
    length=b.length;
}
```

*将box1的地址传给了形参b（b就成为了box1的引用），执行复制构造函数的函数体时，将box1各数据成员的值赋给box2中个数据成员。*



另一种复制形式：类型 对象名1=对象名2

```cpp
Box box2=box1;//用box1初始化box2
```

*可以在一个语句进行多个对象的复制

```cpp
Box box2=box1,box3=box2;
```

**对象赋值vs对象复制**

赋值：对一个已经存在的对象进行赋值，因此必须先定义被赋值的对象。

复制：从无到有建立一个新的对象，并使它与另一个已有的对象完全相同



**普通构造函数vs复制构造函数**

**1、形式不同

```cpp
Box(int h,int w,int len);//普通：类名（形参表列）
Box(Box &b);//复制：类名（类名 &对象名）
```

**2、实参类型

```cpp
Box box1(12,23,34);//普通：实参为整数
Box box2(box1);//复制：实参是对象名
```

**3、在什么情况下被调用

-普通：建立对象时调用

-复制：用已有对象复制一个新对象时被调用。以下三种情况需要复制对象

   ***1、需要新建立一个对象，并用另一同类对象对它初始化。

   ***2、当函数的参数为类的对象

```cpp
void fun(Box b)//形参是类的对象
{}
int main()
{
    Box box1(12,23,34);
    fun(box1);//实参是类的对象，调用函数时将复制一个新对象
    return 0;
}
```

  ***3、函数的返回值是类的对象

```cpp
Box f()//函数f类型为Box类型
{
    Box box1=(12,23,34);
    return box1;//返回值是Box类对象
}
int main()
{
    Box box2;//定义Box类对象box2
    box2=f();//调用f函数，返回Box类的临时对象并将其赋值给box2
    return 0;
}
```

**注意：**

这里box1的生命周期在调用f函数结束时就结束了，因此并不是将box1带回main函数，而是**在函数f结束前执行return语句时，调用Box类中的复制构造函数，按box1复制一个新的对象，然后将它赋值给box2**

总结：以上几种调用复制构造函数都是编译系统自动实现的，不必用户自己调用。


