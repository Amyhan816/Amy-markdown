## 5.1 继承与派生

已存在的类：基类/父类

新建立的类：派生类/子类

类的继承：一个新类从已有的类那里获得其已有特性

类的派生：从父类产生一个新的子类

一代一代派生，最终形成**继承层次结构** 

**单继承**：一个派生类只从一个基类派生

**多重继承**：一个派生类有两个或多个基类



**总结**：派生类是基类的具体化，基类是派生类的抽象。



## 5.2 派生类的声明方式

假如已经声明了类Student：

```cpp
class Student 
{
public:
    void display()
    {
        cout<<"num: "<<num<<endl;
        cout<<"name: "<<name<<endl;
        cout<<"sex: "<<sex<<endl;
    }
private:
    int num;
    string name;
    char sex;
};
```

在此基础上通过单继承建立一个派生类Student1：

```cpp
class Student1:public Student//声明基类是Student
{
public:
    void display_1()//新增的成员函数
    {
        cout<<"age: "<<age<<endl;
        cout<<"address: "<<addr<<endl;
    }
private:
    int age;//新增的数据成员
    string addr;
};
```

*关键字public：公用继承*



声明派生类的一般形式：

**class 派生类名：[继承方式] 基类名**

**{派生类新增加的成员}**



继承方式：public（公用的）、privat（私有的）、protected（受保护的）

//继承方式可选，默认为private



## 5.3 派生类的构成

构造一个派生类包括三部分工作：

1、从基类接收成员。派生类会接受基类**全部**成员（构造函数和析构函数除外）

2、调整从基类接收的成员（可以改变基类成员在派生类中的访问属性/在派生类中声明一个与基类同名的成员，从而覆盖掉基类同名成员。）

3、在声明派生类时增加的成员。



## 5.4 派生类成员的访问属性

（1）基类成员函数访问基类成员/派生类成员函数访问派生类自己增加的成员

*可以访问*！

（2）基类成员函数访问派生类成员

*基类成员函数只能访问基类成员，不能访问派生类成员！*

（3）在派生类外访问派生类成员

*派生类外可以访问派生类公用成员，不能访问派生类私有成员！*

（4）派生类的成员函数访问基类的成员/在派生类外访问基类成员

**要考虑对基类成员所声明的访问属性+派生类所声明对基类的继承方式**



继承方式：

**公用继承（public inheritance）**

基类的公有成员和保护成员在派生类中保持原有访问属性，其私有成员仍为基类私有

**私有继承（private inheritance）**

基类的公有成员和保护成员在派生类中成了私有成员。其私有成员仍为基类私有

**受保护的继承（protected inheritance）**

基类的公有成员和保护成员在派生类中成了保护成员，其私有成员仍为基类私有

//保护成员：不能被外界引用，但可以被派生类的成员引用



### 5.4.1 公用继承

*采用public继承：基类的公用成员和保护成员在派生类中仍保持原本属性，基类的私有成员仍然是基类的私有成员，成为派生类不可访问的成员*

| 在基类的访问属性  | 在派生类的访问属性 |
|:---------:|:---------:|
| private   | 不可访问      |
| public    | public    |
| protected | protected |

公用继承例子：

```cpp
#include<iostream>
using namespace std;
class Student
{
public:
    void get_value()
    {
        cin>>num>>name>>sex;
    }
    void display()
    {
        cout<<"num: "<<num<<endl;
        cout<<"name: "<<name<<endl;
        cout<<"sex: "<<sex<<endl;
    }
private:
    int num;
    string name;
    char sex;
};
class Student1:public Student
{
public:
    void get_value_1()
    {
        cin>>age>>addr;
    }
    void display_1()
    {
        cout<<"age: "<<age<<endl;
        cout<<"address: "<<addr<<endl;
    }
private:
    int age;
    string addr;
};
int main()
{
    Student1 stud;
    stud.get_value();
    stud.get_value_1();
    stud.display();
    stud.display_1();
    return 0;
}

```



### 5.4.2 私有继承

私有基类的公用成员和保护成员在派生类中相当于其私有成员，派生类的成员函数可以访问，派生类外无法访问。

私有基类的私有成员在派生类中成为不可访问的成员，只有基类成员函数可以访问

| 在基类的访问属性  | 在派生类的访问属性 |
| --------- | --------- |
| private   | 不可访问      |
| public    | private   |
| protected | private   |

```cpp
#include<iostream>
using namespace std;
class Student
{
public:
    void get_value()
    {
        cin>>num>>name>>sex;
    }
    void display()
    {
        cout<<"num: "<<num<<endl;
        cout<<"name: "<<name<<endl;
        cout<<"sex: "<<sex<<endl;
    }
private:
    int num;
    string name;
    char sex;
};
class Student1:private Student
{
public:
    void get_value_1()
    {
        get_value();//调用基类公用函数
        cin>>age>>addr;
    }
    void display_1()
    {
        display();//调用基类公用函数
        cout<<"age: "<<age<<endl;
        cout<<"address: "<<addr<<endl;
    }
private:
    int age;
    string addr;
};

```

对于主函数，要注意：

```cpp
int main()
{
    Student1 stud1;
    stud1.display();//错误，私有基类的公用成员函数在派生类中是私有函数
    stud1.display_1();//正确，display_1是派生类的公用成员函数
    stud.age;//错误，age为派生类中的私有成员
    return 0;
}
```



### 5.4.3 保护成员和保护继承

保护成员：与私有成员类似，不能被类外访问。特殊地，保护成员可以被派生类的成员函数引用。

受保护继承：保护基类的所有成员在派生类中都被保护起来，类外不能访问，其公用成员和保护成员可以被其派生类的成员函数访问，私有成员则不可访问

| 在基类的访问属性  | 在派生类中的访问属性 |
| --------- | ---------- |
| private   | 不可访问       |
| public    | protected  |
| protected | protected  |



**总结**

| 派生类中访问属性 | 在派生类中 | 在派生类外部 | 在下层公用派生类中 |
| -------- | ----- | ------ | --------- |
| 公用       | 可以    | 可以     | 可以        |
| 保护       | 可以    | 不可以    | 可以        |
| 私有       | 可以    | 不可以    | 不可以       |
| 不可访问     | 不可以   | 不可以    | 不可以       |

```cpp
#include<iostream>
#include<string>
using namespace std;
class Student
{
public:

protected:
    int num;
    string name;
    char sex;
};
class Student1:protected Student
{
public:
    void get_value1();
    void display1();
private:
    int age;
    string addr;
};
void Student1::get_value1()
{
    cin>>num>>age>>sex;//派生类成员函数引用基类私有成员
    cin>>age>>addr;
}
void Student1::display1()
{
    cout<<"num: "<<num<<endl;//派生类成员函数引用基类私有成员
    cout<<"name: "<<name<<endl;//派生类成员函数引用基类私有成员
    cout<<"sex: "<<sex<<endl;//派生类成员函数引用基类私有成员
    cout<<"age: "<<age<<endl;
    cout<<"address: "<<addr<<endl;
}
int main()
{
    Student1 stud1;
    stud1.get_value1();
    stud1.display1();
    return 0;
}


```



### 5.4.4 多级派生时的访问属性

A<---B<---C

类B为类A的直接派生类，类C为类A的间接派生类

类A是类B的直接基类，是类C的间接基类

```cpp
class A
{
public:
    int i;
protected:
    void f1();
    int j;
private:
    int k;
};
class B:public A
{
public:
    void f2();
protected:
    void f3();
private:
    int m;
};
class C:protected B
{
public:
    void f4();
private:
    int n;
};
```

| 类别     | i   | f1() | j   | k    | f2() | f3() | m    | f4() | n   |
| ------ | --- | ---- | --- | ---- | ---- | ---- | ---- | ---- | --- |
| 基类A    | 公用  | 保护   | 保护  | 私有   |      |      |      |      |     |
| 公用派生类B | 公用  | 保护   | 保护  | 不可访问 | 公用   | 保护   | 私有   |      |     |
| 保护派生类C | 保护  | 保护   | 保护  | 不可访问 | 保护   | 保护   | 不可访问 | 公用   | 私有  |

**无论哪种继承方式，在派生类中是不能访问基类的私有成员的**



## 5.5 派生类的构造函数和析构函数

核心：对继承过来的成员，需要调用派生类构造函数对其成员初始化。为了使派生类数据成员和基类数据成员同时初始化，采用**调用基类的构造函数**来解决该问题



### 5.5.1 简单的派生类的构造函数

```cpp
#include<iostream>
#include<string>
using namespace std;
class Student
{
public:
    Student(int n,string nam,char s)//定义基类构造函数
    {
        num=n;name=nam;sex=s;
    }
    ~Student(){}//基类析构函数
protected:
    int num;
    string name;
    char sex;
};
class Student1:public Student
{
public:
    Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s)//定义派生类构造函数
                                                                      //在函数体中只对派生类新增的数据成员初始化
    {
        age=a;
        addr=ad;
    }
    void show()
    {
        cout<<"num: "<<num<<endl;
        cout<<"name: "<<name<<endl;
        cout<<"sex: "<<sex<<endl;
        cout<<"age: "<<age<<endl;
        cout<<"address: "<<addr<<endl;
    }
    ~Student1(){}//派生类析构函数
private:
    int age;
    string addr;
};
int main()
{
    Student1 stud1(10010,"Wang-li",'f',19,"115 Beijing Road,Shanghai");
    Student1 stud2(10011,"Zhang-fan",'m',21,"213 Shanghai Road,Beijing");
    stud1.show();
    stud2.show();
    return 0;
}


```

**核心：派生类构造函数写法**

派生类构造函数名（总参数表）：基类构造函数名（参数表）

{派生类中新增数据成员初始化语句}

```cpp
Student1(int n,string nam,char s,int a,string ad):Student(n,nam,s)
{
    age=a;address=ad;
}
```

*也可以采用初始化表定义构造函数*

```cpp
Student1(int n,string nam,char s,int a,string ad):String(n,nam,s),age(a),addr(ad){}
```

**执行顺序：派生类构造函数先调用基类构造函数（先初始化num，name，sex），再执行派生类构造函数本身（再初始化age和addre）。释放时，先执行派生类析构函数~~Student1，再执行基类析构函数~Student**



### 5.5.2 有子对象的派生类的构造函数

子对象：类对象中的对象

```cpp
#include<iostream>
#include<string>
using namespace std;
class Student
{
public:
    Student(int n,string nam)
    {
        num=n;
        name=nam;
    }
    void display()
    {
        cout<<"num: "<<num<<endl<<"name: "<<name<<endl;
    }
protected:
    int num;
    string name;
};
class Student1:public Student
{
public:
    Student1(int n,string nam,int n1,string nam1,int a,string ad):Student(n,nam),monitor(n1,nam1)//派生类构造函数
    {
        age=a;
        addr=ad;
    }
    void show()
    {
        cout<<"This student is : "<<endl;
        display();
        cout<<"age: "<<age<<endl;
        cout<<"address: "<<addr<<endl;
    }
    void show_monitor()//成员函数，输出子对象
    {
        cout<<endl<<"Class monitor is : "<<endl;
        monitor.display();//调用基类成员函数
    }
private:
    Student monitor;//定义子对象（班长）
    int age;
    string addr;
};
int main()
{
    Student1 stud1(10010,"Wang-li",10001,"Li-jun",19,"115 Beijing Road,Shanghai");
    stud1.show();
    stud1.show_monitor();
    return 0;
}


```

**核心：**

```cpp
 Student1(int n,string nam,int n1,string nam1,int a,string ad):Student(n,nam),monitor(n1,nam1){age=a;addr=add;}
```

归纳出，定义派生类构造函数的一般形式：

**派生构造函数名（总参数表）：基类构造函数名（参数表），子对象名（参数表）{派生类中新增成员数据初始化语句}**

*顺序·：调用基类构造函数——>调用子对象构造函数——>执行派生类构造函数本身*



### 5.5.3 多层派生时的构造函数

```cpp
#include<iostream>
#include<string>
using namespace std;
class Student
{
public:
    Student(int n,string nam)
    {
        num=n;
        name=nam;
    }
    void display()
    {
        cout<<"num: "<<num<<endl<<"name: "<<name<<endl;
    }
protected:
    int num;
    string name;
};
class Student1:public Student
{
public:
    Student1(int n,string nam,int a):Student(n,nam),age(a){}
    void show()
    {
        display();
        cout<<"age: "<<age<<endl;
    }
private:
    int age;
};
class Student2:public Student1//声明间接派生类student2
{
public:
    Student2(int n,string nam,int a,int s):Student1(n,nam,a),score(s){}
    void show_all()
    {
        show();
        cout<<"score: "<<score<<endl;
    }
private:
    int score;
};

int main()
{
    Student2 stud(10010,"Li",19,89);
    stud.show_all();
    return 0;
}


```

*注意：只须写出上一层派生类的构造函数即可*

```cpp
    Student2(int n,string nam,int a,int s):Student1(n,nam,a),score(s){}//正确
    
    Student2(int n,string nam,int a,int s):Student(n,name),Student1(n,nam,a),score(s){}//错误！！
```



### 5.5.4 派生类构造函数的特殊形式

（1）不需要对派生类新增数据成员初始化，派生类构造函数体可以为空

*作用：只是为了将参数传递给基类构造函数和子对象，并在执行派生类构造函数时调用基类构造函数和子对象构造函数。*

（2）如果基类没有定义/定义了没有参数的构造函数，那么在定义派生类构造函数时可以不写基类构造函数。



### 5.5.5 派生类的析构函数

顺序与构造函数相反：

先执行派生类自己的析构函数，然后调用子对象的析构函数，最后调用基类的析构函数





## 5.6 多重继承

允许一个派生类同时继承多个基类



### 5.6.1 声明多重继承的方法

//如果已经声明了类A、类B、类C，则可以声明多重继承的派生类D：

```cpp
class D:public A,private B,protected C
{类D新增的成员}
```

D按不同的继承方式规则继承A、B、C的属性



### 5.6.2 多重继承派生类的构造函数

```cpp
派生类构造函数名（总参数表）：基类1构造函数（参数表），基类2构造函数（参数表），基类3构造函数（参数表列）
{派生类中新增数据成员初始化语句}
```

//例 声明教师类和学生类，用多重继承声明一个在职研究生派生类.教师类中包括名字、年龄、职称。学生类包括姓名、性别、成绩。

```cpp
#include<iostream>
#include<string>
using namespace std;

class Teacher//声明类Teacher
{
public:
    Teacher(string nam,int a,string t):name(nam),age(a),title(t){}
    void display()
    {
        cout<<"name: "<<name<<endl;
        cout<<"age: "<<age<<endl;
        cout<<"title: "<<title<<endl;
    }
protected:
    string name;
    int age;
    string title;
};
class Student//声明类Student
{
    public:
        Student(string nam,char s,float sco):name1(nam),sex(s),score(sco){}
        void display1()
        {
            cout<<"name: "<<name1<<endl;
            cout<<"sex: "<<sex<<endl;
            cout<<"score: "<<score<<endl;
        }
    protected:
        string name1;
        char sex;
        float score;
};
class Graduate:public Teacher,public Student//声明多重继承的派生类Graduate
{
public:
    Graduate(string nam,int a,char s,string t,float sco,float w):Teacher(nam,a,t),Student(nam,s,sco),wage(w){}
    void show()
    {
        cout<<"name: "<<name<<endl;
        cout<<"age: "<<age<<endl;
        cout<<"sex: "<<sex<<endl;
        cout<<"title: "<<title<<endl;
        cout<<"score: "<<score<<endl;
        cout<<"wages: "<<wage<<endl;
    }
private:
    float wage;
};
int main()
{
    Graduate grad1("Wang-li",24,'f',"assistant",89.5,2400);
    grad1.show();
    return 0;
}


```

*注意到，两个基类的姓名分别用name和name1来命名。如果都有name，会出现歧义性，编译系统不知道该选哪个基类的name*

*但是本程序中的这种办法并不高明，大部分基类都是提前写好的，不能修改一个name1一个name2，那么怎么解决？*

**方法：在两个基类中可以都使用一个数据成员名name，而在show函数中引用数据成员时指名其作用域**

```cpp
cout<<"name: "<<Teacher::name<<endl;
```



### 5.6.3 多重继承引起的二义性问题

#### 1、两个基类有同名成员

```cpp
class A
{
    public:
     int a;
     void display();
};
class B
{
    public:
     int a;
     void display();
};
class C:public A,public B
{
    public:
     int b;
     void show();
};
```

*基类A、B都有数据成员a和成员函数display，以下程序编译会出错*

```cpp
C c1;
c1.a=3;
c1.display();
```

解决方法：**用基类名限定**

```cpp
c1.A::a=3;
c1.A::display();
```

*如果是在派生类C中的成员函数show访问基类A的display和a，则不用写对象名*

```cpp
A::a=3;//指当前对象
A::display();
```

#### 2、两个基类和派生类三者都有同名成员

*把C类声明改为*

```cpp
class C:public A,public B
{
    int a;
    void display();
};
```

*此时有三个display（）和三个a*

```cpp
C c1;
c1.a=3;
c1.display();
```

程序可以通过编译，访问的是**派生类C的成员**

**规则：基类的同名成员在派生类中被屏蔽，成为“不可见”的。（或者说，派生类新增加的同名成员覆盖了基类中的同名成员）

*不同的成员函数，只有在函数名和参数个数相同、类型相匹配的情况下才发生同名覆盖，如果只有函数名相同而参数名不同，则是函数的重载*



如果要在派生类中访问基类A中的成员，应指明作用域A：


```cpp
c1.A::a=3;//表示是派生类对象c1中的基类A的数据成员a
c1.A::display();//表示是派生类对象c1中的基类A中的成员函数display
```

#### 3、如果类A和类B是从同一个基类派生的

```cpp
class N
{
    public:
    int a;
    void display(){cout<<"A::a="<<a<<endl;}
};
class A:public N
{
    public:
    int a1;
};
class B:public N
{
    public:
    int a2;
};
class C:public A,public B
{
    public:
    int a3;
    void show(){cout<<"a3= "<<a3<<endl;}
};
int main()
{
    C c1;
}
```

//虽然类A和类B没有定义a和display()，但他们都继承了类N的a和display()。

它们是类N成员的拷贝，类A和类B中的数据成员a代表两个不同的存储单元，可以分别存放不同的数据。

在程序中可通过类A、B的构造函数去调用基类N的构造函数，分别对类A、B中的a初始化

```cpp
//通过类N的直接派生名指出要访问类N哪个派生类的基类成员
c1.A::a=3;
c1.A::display();
```



### 5.6.4 在继承间接共同基类时减少数据冗余——用虚基类

虚基类：在继承间接共同基类时只保留一份成员

  A    间接基类

B  C  基类

  D    派生类

*采用虚基类，将A作为虚基类：*

```cpp
class A
{};
class B:virtual public A
{};
class C:virtual public A
{};
```

其一般格式为

**class 派生类名:virtual 继承方式 基类名**



*为保证虚基类在派生类中只继承一次，应当在该基类的所有直接派生类中声明为虚基类*



*虚基类的初始化*：

```cpp
class A//定义基类A
{
    A(int i){}//基类构造函数，有1个参数
};
class B:virtual public A//A作为B的虚基类
{
    B(int n):A(n){}//类B构造函数，在初始化表中对虚基类初始化
};
class C:virtual public A//A作为C的虚基类
{
    C(int n):A(n){}//类C构造函数，在初始化表中对虚基类初始化
};
class D:public B,public C//类D的构造函数，在初始化表中对所有基类初始化
{
    D(int n):A(n),B(n),C(n){}
};
```

*注意：在最后的派生类中不仅要负责对其直接基类进行初始化，还要负责对虚基类初始化！*

**虽然类B、C、D都调用了类A的构造函数，但事实上C++编译系统只执行最后的派生类对虚基类的构造函数的调用。



虚基类的应用举例：

eg.添加共同的基类Person

```cpp
#include<iostream>
#include<string>
using namespace std;

class Person
{
public:
    Person(string nam,char s,int a):name(nam),sex(s),age(a){}//构造函数
protected:
    string name;
    char sex;
    int age;
};

//声明Person的直接派生类Teacher
class Teacher:virtual public Person//声明Person为公用继承的虚基类
{
public:
    Teacher(string nam,char s,int a,string t):Person(nam,s,a),title(t){}//构造函数
protected:
    string title;
};

//声明Person的直接派生类Student
class Student:virtual public Person//声明Person为公用继承的虚基类
{
    public:
        Student(string nam,char s,int a,float sco):Person(nam,s,a),score(sco){}//构造函数
    protected:
        float score;
};
//声明多重继承的派生类Graduate
class Graduate:public Teacher,public Student//Teacher和Student为直接基类
{
public:
    Graduate(string nam,char s,int a,string t,float sco,float w):Person(nam,s,a),Teacher(nam,s,a,t),Student(nam,s,a,sco),wage(w){}//构造函数
    void show()
    {
        cout<<"name: "<<name<<endl;//在本类中只保留了一份基类的成员，可以直接引用name、sex、age
        cout<<"sex: "<<sex<<endl;
        cout<<"age: "<<age<<endl;
        cout<<"title: "<<title<<endl;
        cout<<"score: "<<score<<endl;
        cout<<"wages: "<<wage<<endl;
    }
private:
    float wage;
};
int main()
{
    Graduate grad1("Wang-li",'f',19,"assistant",89.5,2400);
    grad1.show();
    return 0;
}


```

不建议使用多重继承！！



## 5.7 基类与派生类的转换

**公有派生类：基类真正的子类型，它完整地继承了基类的功能

**赋值兼容：不同类型数据之间的自动转换和赋值（int->double）

*基类与派生类对象之间也有赋值兼容的关系*

**1、派生类对象可以向基类对象赋值**

```cpp
A a1;//定义基类A的对象a1
B b1;//定义A类的公用派生类B对象b1
a1=b1;//用派生类对象b1对基类a1进行赋值
```

*“大材小用”：在赋值时舍弃派生类自己的成员*

·只能用子类对象对其基类对象赋值，而不能用基类对象对子类对象赋值

·同一基类的不同派生类对象之间也不能赋值



**2、派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化**

如已定义基类A对象a1，可以定义a1的引用变量：

```cpp
A a1;
B b1;
A& r=a1;//定义基类A对象的引用r，并用a1对其初始化
```

此时r和a1共享同一段存储单元，可以用子类对象初始化r。将最后一行改为

```cpp
A& r=b1;
```

*注意：此时r不是b1的别名，它只是b1基类部分的别名，r与b1具有相同的起始地址。*



**3、如果函数的参数是基类对象或基类对象的引用，相应的实参可以用子类对象**

```cpp
void fun(A& r)
{cout<<r.num<<endl;}
```

*在调用fun函数时可以用派生类B的对象b1作实参*

```cpp
fun(b1);//输出b1的基类数据成员num的值
```



**4、派生类对象的地址可以赋给指向基类对象的指针变量，也就是说，指向基类对象的指针变量也可以用来指向派生类对象**

```cpp
#include<iostream>
#include<string>
using namespace std;

class Student
{
   public:
       Student(int,string,float);
       void display();
   private:
    int num;
    string name;
    float score;
};
Student::Student(int n,string nam,float s)
{
    num=n;
    name=nam;
    score=s;
}
void Student::display()
{
    cout<<endl<<"num: "<<num<<endl;
    cout<<"name: "<<name<<endl;
    cout<<"score: "<<score<<endl;
}
class Graduate:public Student
{
public:
    Graduate(int,string,float,float);
    void display();
private:
    float wage;
};
Graduate::Graduate(int n,string nam,float s,float w):Student(n,nam,s),wage(w){}
void Graduate::display()
{
    Student::display();
    cout<<"wage= "<<wage<<endl;
}
int main()
{
    Student stud1(1001,"Li",87.5);
    Graduate grad1(2001,"Wang",98.5,1000);
    Student *pt=&stud1;//定义指向Student类对象的指针并指向stud1
    pt->display();//调用stud1.display函数
    pt=&grad1;//指针指向grad1
    pt->display();//调用grad1.display
    return 0;
}


```

<img src="file:///C:/Users/a3341/Pictures/Typedown/86ccfe38-9366-4d02-b8bf-6461095cdf1f.png" title="" alt="86ccfe38-9366-4d02-b8bf-6461095cdf1f" style="zoom:50%;">

*注意：为什么在pt指向grad1的时候，没有根据同名覆盖原则输出wage？*

**因为pt指向的是Student类对象。**.即pt指向的是grad1从基类继承的部分！

**通过指向基类对象的指针，只能访问派生类中的基类成员，而不能访问派生类增加的成员**



## 5.8 继承和组合

**类的组合**：在一个类中以另一个类的对象作为数据成员

```cpp
class Teacher//声明教师类
{
public:
    ...
private:
    int num;
    string name;
    char sex;
};
class BirthDate//声明生日类
{
public:
    ... 
private:
    int year;
    int month;
    int day;
};
class Professor:public Teacher//声明教授类
{
public:
    ... 
private:
    BirthDate birthday;//BirthDate类的对象作为数据成员
};
```

继承：“是”的关系（白猫是猫） 

组合：“有”的关系（教授有一个生日属性）

**继承是纵向的，组合是横向的**



```cpp
void fun1(Teacher&);
void fun2(BirthDate&);
```

```cpp
int main()
{
    fun1(prof1);//正确，形参为T类对象的引用，实参为T类的子类对象，与之赋值兼容
    fun2(prof1.birthday);//正确，实参与形参类型相同，都是BirthDate类对象
    fun2(prof1);//错误，形参要求BirthDate类对象，实参为Professor类型，不匹配
}
```


